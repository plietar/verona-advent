use "../lib/list.verona"
use "../lib/tree.verona"

class Main
{
  // Pattern matching on a loop variable seems to cause lots of problems during
  // type inference. Use recursion to work around this.
  print_node(node: (ListNode[U64 & imm] & mut) | (None & imm))
  {
    match node {
      var node: ListNode[U64 & imm] => {
        Builtin.print1("{}\n", node.value);
        Main.print_node(node.next);
      }
      var _: None => { }
    }
  }
  print_list(list: List[U64 & imm] & mut) 
  {
    Main.print_node(list.head);
  }

  // Type inference was picking List[U64] as the return type of List.create(),
  // instead of List[U64 & imm], even though the list got passed to print_list.
  //
  // We use a separate function to ascribe the type we actually want.
  make_list(): List[U64 & imm] & iso {
    List.create()
  }

  part1(node: (ListNode[U64 & imm] & mut) | (None & imm), seen: Tree[U64 & imm] & mut, target: U64 & imm): (U64 & imm) | (None & imm)
  {
    match node {
      var node: ListNode[U64 & imm] => {
        var partner = target - node.value;
        if seen.contains(partner) {
          partner * node.value
        } else {
          seen.insert(node.value);
          Main.part1(node.next, seen, target)
        }
      }
      var _: None => None.create(),
    }
  }

  part2(data: List[U64 & imm] & mut, node: (ListNode[U64 & imm] & mut) | (None & imm)): (U64 & imm) | (None & imm)
  {
    match node {
      var node: ListNode[U64 & imm] => {
        var target = 2020 - node.value;
        var seen = mut-view (Tree.create());
        match Main.part1(data.head, seen, target) {
          var product: U64 => {
            product * node.value
          }
          var _: None => {
            Main.part2(data, node.next)
          }
        }
      }
      var _: None => None.create(),
    }
  }

  main() {
    var data = mut-view (Main.make_list());
    var seen = mut-view (Tree.create());

    var c = 1;
    while c {
      match IO.read_u64() {
        var x: U64 => data.push_back(x),
        var _: None => c = 0,
      };
    };

    Builtin.print1("Part 1: {}\n", Main.part1(data.head, seen, 2020));
    Builtin.print1("Part 2: {}\n", Main.part2(data, data.head));
  }
}
